#!/usr/bin/env python

import argparse
import matplotlib 
import matplotlib.pyplot as plt
import numpy as np

#This code plays a number game. Given a list of more than three integers, 
#it will find the difference between each pair in the list, then go on to find
#difference between each pair in the subsequent list. This process will continue
#until the list of differences begins to repeat. All resulting lists contain
# positive integers, no matter the sign of the input

#create parser
parser=argparse.ArgumentParser()

#define command line options
#add an --int option that requires a list of at least 1 integer to run the code
parser.add_argument('--int', type=int, required=True, nargs='+', help='''
A list of integers needed to run the simulation. The list elements are the adjacent vertices of a polygon. Subsquent lists are created by taking the absolute value of the difference between adjacent elements in the preceding list.'''
)
 
#parse command line
args=parser.parse_args()

#command line input turned into a list
values=args.int

#Create a differences function that find the difference between two adjacent
#elements of a list, starting with the last and first. The function than appends
#the result into a list called output
def differences(input):
    output=[]
    for i in range(len(input)):
        output.append(abs(input[i]-input[i-1]))
    return output

#number of integers to be used
n=len(values)
if n<3:
    print 'Please choose three or more integers.'
else:
#First polygon
    print 'The original polygon has at its vertices: '+str(values)

#Creating the plot
    ax=plt.subplot(111)
    ax.set_title('Number Patterns')
 

#Master list containing all lists generated by the original input and the 
#difference function
    master=[]

#loop over each set of differences until they begin to repeat.
    while values != differences(values):
        if values not in master:
            master.append(values)
            j=1
            while j<=len(master):
                i=0
                while i<n:
                    max_t=(i*2*np.pi/n)+(np.pi/(6*j))-(j*np.pi/n)
                    min_t=(i+1)*2*np.pi/n-(np.pi/(6*j))+(j*np.pi/n)
                    t=np.linspace(max_t,min_t,100)
                    x=(j+1)*np.cos(t)
                    y=(j+1)*np.sin(t)
                    plt.plot(x,y,'b')
                    ax.set_ylim([-(j+5),(j+5)])
                    ax.set_xlim([-(j+5),(j+5)])
                    x=(j+1)*np.cos((i*2*np.pi/n)-(j*np.pi/n))
                    y=(j+1)*np.sin((i*2*np.pi/n)-(j*np.pi/n))
                    plt.plot(x,y,'w.', markersize=60)
                    ax.text(x,y, str(master[j-1][i]),ha='center', va='center')
                    
                    i=i+1
                j=j+1
            values=differences(values)
            print 'The next polygon has at its vertices: '+str(values)
        else:
            print '''After this the list of vertices repeats. '''
            break
    print '''There is no more significant output.'''
#The deepest sequence of output I could find for n=4 was eight for the list
#9,7,6,5
plt.show()





